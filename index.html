<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Runner Challenge</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }

        body {
            background: radial-gradient(circle at top, #667eea 0%, #111827 50%, #020617 100%);
        }

        #gameRoot {
            position: relative;
            width: 100vw;
            height: 100vh;
        }

        #gameCanvas {
            position: absolute;
            inset: 0;
            width: 100%;
            height: 100%;
            display: block;
            background: #000;
        }

        /* ===== HUD OVERLAYS ===== */

        .hud {
            position: absolute;
            z-index: 10;
            color: white;
            font-size: 14px;
        }

        .hud-top-left {
            top: 10px;
            left: 10px;
            background: rgba(15, 23, 42, 0.85);
            padding: 10px 14px;
            border-radius: 10px;
            min-width: 180px;
        }

        .hud-top-right {
            top: 10px;
            right: 10px;
            background: rgba(15, 23, 42, 0.85);
            padding: 10px 14px;
            border-radius: 10px;
            min-width: 260px;
        }

        .hud-title {
            font-weight: bold;
            color: #a5b4fc;
            margin-bottom: 4px;
        }

        .hud-line {
            margin: 2px 0;
        }

        .hud-label {
            color: #cbd5f5;
        }

        .hud-value {
            font-weight: bold;
        }

        .coins-line {
            margin-bottom: 6px;
        }

        .coins-line span {
            font-weight: bold;
            color: #facc15;
        }

        /* Timer bar in HUD */
        .timer-bar {
            width: 100%;
            height: 18px;
            background: rgba(15, 23, 42, 0.9);
            border-radius: 12px;
            overflow: hidden;
            margin: 4px 0 6px 0;
            position: relative;
            border: 1px solid rgba(148, 163, 184, 0.5);
        }

        .timer-fill {
            height: 100%;
            background: linear-gradient(90deg, #22c55e, #16a34a);
            transition: width 0.1s linear, background 0.3s;
            border-radius: 12px;
        }

        .timer-fill.warning {
            background: linear-gradient(90deg, #fdba74, #fb923c);
        }

        .timer-fill.critical {
            background: linear-gradient(90deg, #fb7185, #f43f5e);
            animation: pulse 0.6s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.6; }
        }

        .timer-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-weight: bold;
            font-size: 12px;
        }

        .hud-buttons {
            display: flex;
            gap: 6px;
            margin-top: 4px;
            flex-wrap: wrap;
        }

        .hud-btn {
            flex: 1;
            min-width: 70px;
            padding: 4px 6px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-size: 12px;
            font-weight: bold;
            color: white;
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%);
        }

        .hud-btn.shop {
            background: linear-gradient(135deg, #f97316 0%, #f97316 100%);
        }

        .hud-btn.scores {
            background: linear-gradient(135deg, #0ea5e9 0%, #22c55e 100%);
        }

        .hud-btn.menu {
            background: linear-gradient(135deg, #6b7280 0%, #4b5563 100%);
        }

        .hud-btn:active {
            transform: scale(0.96);
        }

        .marker-info {
            margin-top: 6px;
            padding: 4px 6px;
            border-radius: 6px;
            background: rgba(250, 204, 21, 0.12);
            color: #facc15;
            font-size: 12px;
        }

        .special-level-indicator {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(240, 149, 255, 0.95);
            color: white;
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 13px;
            font-weight: bold;
            z-index: 10;
            animation: glow 1.5s infinite;
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 10px rgba(240, 149, 255, 0.4); }
            50% { box-shadow: 0 0 22px rgba(240, 149, 255, 0.9); }
        }

        /* ===== MOBILE CONTROLS ===== */

        .mobile-controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 10;
            display: none;
            user-select: none;
        }

        .mobile-controls-row {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin: 4px 0;
        }

        .mobile-btn {
            width: 60px;
            height: 60px;
            border-radius: 16px;
            border: none;
            font-size: 24px;
            font-weight: bold;
            background: radial-gradient(circle at top, #4f46e5 0%, #1d2a3a 70%);
            color: white;
            box-shadow: 0 6px 14px rgba(15, 23, 42, 0.8);
            cursor: pointer;
        }

        .mobile-btn:active {
            transform: scale(0.95);
        }

        .mobile-marker-btn {
            width: 150px;
            font-size: 18px;
            background: linear-gradient(135deg, #facc15 0%, #fb923c 100%);
            color: #1f2937;
        }

        @media (max-width: 900px) {
            .mobile-controls {
                display: block;
            }
        }

        /* ===== MODALS ===== */

        .modal {
            position: fixed;
            inset: 0;
            background: rgba(15, 23, 42, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 30;
        }

        .modal.show {
            display: flex;
        }

        .modal-content {
            background: #0f172a;
            color: white;
            padding: 24px 24px 18px 24px;
            border-radius: 20px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(148, 163, 184, 0.5);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 14px;
        }

        .modal-header h2 {
            color: #a5b4fc;
        }

        .close-btn {
            background: #ef4444;
            color: white;
            border: none;
            padding: 6px 10px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 13px;
        }

        /* Shop grid */

        .shop-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 12px;
            margin-top: 14px;
        }

        .shop-item {
            background: linear-gradient(135deg, #4f46e5 0%, #7c3aed 100%);
            padding: 14px;
            border-radius: 12px;
            text-align: center;
            color: white;
            cursor: pointer;
            border: 2px solid transparent;
            transition: transform 0.15s;
            font-size: 14px;
        }

        .shop-item:hover {
            transform: translateY(-2px);
        }

        .shop-item.owned {
            border-color: #22c55e;
            background: linear-gradient(135deg, #16a34a 0%, #22c55e 100%);
        }

        .shop-item.equipped {
            box-shadow: 0 0 16px rgba(250, 204, 21, 0.8);
            border-color: #facc15;
        }

        .shop-item-icon {
            font-size: 36px;
            margin-bottom: 6px;
        }

        .shop-item-price {
            margin-top: 4px;
            font-weight: bold;
            color: #facc15;
        }

        /* Scoreboard table */

        .scoreboard-table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 10px;
            font-size: 15px;
        }

        .scoreboard-table td {
            padding: 4px 2px;
            vertical-align: middle;
        }

        .scoreboard-table td:first-child {
            font-weight: bold;
            color: #cbd5f5;
        }

        .reset-scores-btn {
            margin-top: 12px;
            padding: 8px 12px;
            border-radius: 10px;
            border: none;
            background: #ef4444;
            color: white;
            font-weight: bold;
            cursor: pointer;
            font-size: 13px;
        }

        .reset-scores-btn:hover {
            background: #dc2626;
        }

        /* Menu modal buttons */

        .menu-btn {
            width: 100%;
            padding: 10px 12px;
            border-radius: 10px;
            border: none;
            font-size: 15px;
            font-weight: bold;
            margin-top: 8px;
            cursor: pointer;
        }

        .menu-btn.primary {
            background: linear-gradient(135deg, #4f46e5 0%, #6366f1 100%);
            color: white;
        }

        .menu-btn.secondary {
            background: #1f2937;
            color: #e5e7eb;
            border: 1px solid #4b5563;
        }

        .menu-btn:disabled {
            opacity: 0.5;
            cursor: default;
        }

        /* Victory / chest / game over popups */

        .victory-message, .special-level-message, .chest-message, .game-over-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 26px 30px;
            border-radius: 20px;
            color: white;
            font-size: 20px;
            text-align: center;
            display: none;
            z-index: 25;
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.7);
        }

        .victory-message.show,
        .special-level-message.show,
        .chest-message.show,
        .game-over-message.show {
            display: block;
            animation: bounceIn 0.6s;
        }

        .victory-message {
            background: linear-gradient(135deg, #22c55e 0%, #4ade80 100%);
        }

        .special-level-message {
            background: linear-gradient(135deg, #f97316 0%, #ec4899 100%);
        }

        .chest-message {
            background: linear-gradient(135deg, #facc15 0%, #1e40af 100%);
        }

        .game-over-message {
            background: linear-gradient(135deg, #f97373 0%, #b91c1c 100%);
        }

        .restart-btn {
            margin-top: 14px;
            padding: 8px 14px;
            font-size: 14px;
            background: white;
            color: #b91c1c;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            font-weight: bold;
        }

        .restart-btn:hover {
            transform: scale(1.03);
        }

        @keyframes bounceIn {
            0% { transform: translate(-50%, -50%) scale(0); }
            50% { transform: translate(-50%, -50%) scale(1.08); }
            100% { transform: translate(-50%, -50%) scale(1); }
        }
    </style>
</head>
<body>
<div id="gameRoot">
    <canvas id="gameCanvas"></canvas>

    <!-- HUD LEFT -->
    <div class="hud hud-top-left">
        <div class="hud-title">üèÉ Maze Runner</div>
        <div class="hud-line">
            <span class="hud-label">Level:</span>
            <span class="hud-value" id="chunkCounter">1</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">Difficulty:</span>
            <span class="hud-value" id="difficultyDisplay">üü¢ Beginner</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">Steps:</span>
            <span class="hud-value" id="stepCounter">0</span>
        </div>
        <div class="marker-info">
            üìç Markers: <span id="markerCount">0</span>
        </div>
        <div id="chunkIndicator" style="margin-top:6px; font-size:12px; color:#a5b4fc;">
            Level 1 - üü¢ Beginner
        </div>
    </div>

    <!-- HUD RIGHT -->
    <div class="hud hud-top-right">
        <div class="coins-line">
            üí∞ Bank: <span id="bankCoinCount">0</span> ¬∑ Run: <span id="runCoinCount">0</span>
        </div>
        <div class="timer-bar">
            <div class="timer-fill" id="timerFill" style="width: 100%"></div>
            <div class="timer-text" id="timerText">90s</div>
        </div>
        <div class="hud-line">
            <span class="hud-label">üî≠ Vision:</span>
            <span class="hud-value" id="visionLevel">Normal</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">‚è∞ Time Bonus:</span>
            <span class="hud-value" id="timeBonus">+0s</span>
        </div>
        <div class="hud-line">
            <span class="hud-label">üëÅÔ∏è Reveal:</span>
            <span class="hud-value" id="revealPower">Inactive</span>
        </div>

        <div class="hud-buttons">
            <button class="hud-btn shop" onclick="openShop()">üõçÔ∏è Shop</button>
            <button class="hud-btn scores" onclick="openScoreboard()">üìä Scores</button>
            <button class="hud-btn menu" onclick="openMenu()">‚ò∞ Menu</button>
        </div>
    </div>

    <!-- Special level indicator -->
    <div class="special-level-indicator" id="specialIndicator" style="display:none;">
        ‚ú® BONUS LEVEL ‚ú®
    </div>

    <!-- Mobile controls -->
    <div class="mobile-controls" id="mobileControls">
        <div class="mobile-controls-row">
            <button class="mobile-btn" data-dir="up">‚¨ÜÔ∏è</button>
        </div>
        <div class="mobile-controls-row">
            <button class="mobile-btn" data-dir="left">‚¨ÖÔ∏è</button>
            <button class="mobile-btn" data-dir="down">‚¨áÔ∏è</button>
            <button class="mobile-btn" data-dir="right">‚û°Ô∏è</button>
        </div>
        <div class="mobile-controls-row">
            <button class="mobile-btn mobile-marker-btn" id="mobileMarkerBtn">üìç Marker</button>
        </div>
    </div>

    <!-- Shop Modal -->
    <div class="modal" id="shopModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üõçÔ∏è Cosmetic Shop</h2>
                <button class="close-btn" onclick="closeShop()">Close</button>
            </div>
            <div style="text-align:center; margin-bottom:8px;">
                üí∞ Bank Coins: <span id="shopBankCoinCount">0</span>
            </div>
            <div class="shop-grid" id="shopGrid"></div>
        </div>
    </div>

    <!-- Scoreboard Modal -->
    <div class="modal" id="scoreboardModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üìä Scoreboard</h2>
                <button class="close-btn" onclick="closeScoreboard()">Close</button>
            </div>
            <table class="scoreboard-table">
                <tr>
                    <td>üèÜ Highest Level Reached</td>
                    <td id="sbBestLevel">0</td>
                </tr>
                <tr>
                    <td>‚è±Ô∏è Fastest Level Time</td>
                    <td id="sbFastestTime">‚Äî</td>
                </tr>
                <tr>
                    <td>üí∞ Bank Coins</td>
                    <td id="sbBankCoins">0</td>
                </tr>
                <tr>
                    <td>üíé Most Coins in One Run</td>
                    <td id="sbBestCoinsRun">0</td>
                </tr>
                <tr>
                    <td>üéÆ Total Runs Played</td>
                    <td id="sbRunsPlayed">0</td>
                </tr>
            </table>
            <button class="reset-scores-btn" onclick="resetScores()">Reset Scores</button>
        </div>
    </div>

    <!-- Main Menu Modal (New Game / Continue) -->
    <div class="modal show" id="menuModal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>üèÉ Maze Runner Challenge</h2>
                <button class="close-btn" onclick="closeMenu()">Close</button>
            </div>
            <p style="margin-bottom:10px;">
                Choose <strong>Continue</strong> to load your last saved run, or start a <strong>New Game</strong>.
            </p>
            <button class="menu-btn primary" onclick="startNewGame()">‚≠ê New Game</button>
            <button class="menu-btn secondary" id="continueBtn" onclick="continueGame()">‚ñ∂ Continue</button>
        </div>
    </div>

    <!-- Popups -->
    <div class="victory-message" id="victoryMessage">
        üéâ Level Complete! üéâ<br>
        <span style="font-size: 15px; margin-top: 8px; display: block;">Next level loading...</span>
    </div>

    <div class="special-level-message" id="specialLevelMessage">
        ‚ú® BONUS LEVEL! ‚ú®<br>
        <span style="font-size: 15px; margin-top: 8px; display: block;">Extra coins and rewards await!</span>
    </div>

    <div class="chest-message" id="chestMessage">
        üì¶ Chest Opened! üì¶<br>
        <span style="font-size: 15px; margin-top: 8px; display: block;" id="chestReward">+50 coins!</span>
    </div>

    <div class="game-over-message" id="gameOverMessage">
        ‚è∞ Time's Up! ‚è∞<br>
        <span style="font-size: 15px; margin-top: 8px; display: block;">
            You completed <span id="finalChunks">0</span> levels!
        </span>
        <span style="font-size: 14px; display: block; margin-top:4px;">
            Run Coins Earned: <span id="finalCoins">0</span> üí∞ (Banked)
        </span>
        <button class="restart-btn" onclick="handleRestart()">New Game</button>
    </div>
</div>

<script>
    // ==================== GAME CONFIG ====================
    const CONFIG = {
        CHUNK_SIZE: 21,
        BASE_VISIBILITY_RADIUS: 6,
        BASE_MARKER_VISIBILITY_RADIUS: 5,
        SPECIAL_LEVEL_CHANCE: 0.15,
        CHEST_SPAWN_CHANCE: 0.3,
        BEGINNER_TIME: 90,
        AVERAGE_TIME: 60,
        EXPERT_TIME: 45,
        PRO_TIME: 30,
        INSANE_TIME: 20
    };

    // We compute tile size dynamically based on canvas size.
    function getTileSize() {
        const minSide = Math.min(canvas.width, canvas.height);
        return minSide / CONFIG.CHUNK_SIZE;
    }

    // ==================== COSMETICS ====================
    const COSMETICS = {
        colors: [
            { id: 'default', name: 'Default Blue', color: '#667eea', price: 0, owned: true },
            { id: 'red', name: 'Ruby Red', color: '#f56565', price: 100, owned: false },
            { id: 'green', name: 'Emerald Green', color: '#48bb78', price: 100, owned: false },
            { id: 'purple', name: 'Royal Purple', color: '#9f7aea', price: 150, owned: false },
            { id: 'gold', name: 'Golden', color: '#ffd700', price: 200, owned: false },
            { id: 'cyan', name: 'Cyber Cyan', color: '#00ffff', price: 150, owned: false },
            { id: 'pink', name: 'Sakura Pink', color: '#ff69b4', price: 150, owned: false },
            { id: 'orange', name: 'Sunset Orange', color: '#ff8c00', price: 100, owned: false }
        ],
        trails: [
            { id: 'none', name: 'No Trail', effect: 'none', price: 0, owned: true },
            { id: 'sparkle', name: 'Sparkle Trail', effect: 'sparkle', price: 250, owned: false },
            { id: 'fire', name: 'Fire Trail', effect: 'fire', price: 300, owned: false },
            { id: 'rainbow', name: 'Rainbow Trail', effect: 'rainbow', price: 500, owned: false }
        ]
    };

    // ==================== POWER-UPS ====================
    const POWERUP_TYPES = {
        VISION: { emoji: 'üî≠', color: '#4299e1', duration: 15000 },
        TIME: { emoji: '‚è∞', color: '#48bb78', duration: 0 },
        REVEAL: { emoji: 'üëÅÔ∏è', color: '#ed8936', duration: 8000 }
    };

    // ==================== SCOREBOARD / BANK ====================
    const SCOREBOARD_KEY = 'mazeRunnerScoreboard';
    const SAVE_KEY = 'mazeRunnerSave';

    let scoreboard = {
        bestLevel: 0,
        fastestLevelTime: null, // seconds
        bankCoins: 0,
        bestCoinsRun: 0,
        runsPlayed: 0
    };

    function loadScores() {
        try {
            const data = localStorage.getItem(SCOREBOARD_KEY);
            if (data) {
                const parsed = JSON.parse(data);
                scoreboard.bestLevel = parsed.bestLevel || 0;
                scoreboard.fastestLevelTime = parsed.fastestLevelTime ?? null;
                scoreboard.bankCoins = parsed.bankCoins || 0;
                scoreboard.bestCoinsRun = parsed.bestCoinsRun || 0;
                scoreboard.runsPlayed = parsed.runsPlayed || 0;
            }
        } catch (e) {
            console.warn('Could not load scores:', e);
        }
        updateScoreboardUI();
        updateCoinDisplay();
    }

    function saveScores() {
        try {
            localStorage.setItem(SCOREBOARD_KEY, JSON.stringify(scoreboard));
        } catch (e) {
            console.warn('Could not save scores:', e);
        }
        updateScoreboardUI();
        updateCoinDisplay();
    }

    function updateScoreboardUI() {
        const bestLvlEl = document.getElementById('sbBestLevel');
        if (!bestLvlEl) return; // modal not built yet
        const fastTimeEl = document.getElementById('sbFastestTime');
        const bankEl = document.getElementById('sbBankCoins');
        const bestCoinsRunEl = document.getElementById('sbBestCoinsRun');
        const runsPlayedEl = document.getElementById('sbRunsPlayed');

        bestLvlEl.textContent = scoreboard.bestLevel;
        bankEl.textContent = scoreboard.bankCoins;
        bestCoinsRunEl.textContent = scoreboard.bestCoinsRun;
        runsPlayedEl.textContent = scoreboard.runsPlayed;

        if (scoreboard.fastestLevelTime == null) {
            fastTimeEl.textContent = '‚Äî';
        } else {
            fastTimeEl.textContent = scoreboard.fastestLevelTime.toFixed(1) + 's';
        }
    }

    function resetScores() {
        if (!confirm('Reset all saved scores and bank coins?')) return;
        scoreboard = {
            bestLevel: 0,
            fastestLevelTime: null,
            bankCoins: 0,
            bestCoinsRun: 0,
            runsPlayed: 0
        };
        saveScores();
    }

    function openScoreboard() {
        updateScoreboardUI();
        document.getElementById('scoreboardModal').classList.add('show');
    }

    function closeScoreboard() {
        document.getElementById('scoreboardModal').classList.remove('show');
    }

    // ==================== GAME STATE ====================
    const gameState = {
        maze: [],
        player: { x: 1, y: 1 },
        goal: { x: 0, y: 0 },
        visited: [],
        markers: [],
        powerups: [],
        coins: [],
        chests: [],
        trailParticles: [],
        activePowerups: {
            vision: { active: false, endTime: 0 },
            reveal: { active: false, endTime: 0 }
        },
        playerCosmetics: {
            color: '#667eea',
            trail: 'none'
        },
        totalCoins: 0, // run coins
        steps: 0,
        currentChunk: 1,
        chunkOffsetX: 0,
        chunkOffsetY: 0,
        isMoving: false,
        animationProgress: 0,
        previousPosition: { x: 1, y: 1 },
        timeRemaining: 90,
        maxTimeForLevel: 90,
        lastFrameTime: Date.now(),
        gameOver: false,
        visibilityRadius: CONFIG.BASE_VISIBILITY_RADIUS,
        isSpecialLevel: false,
        levelStartTime: null,
        fastestLevelTimeThisRun: null
    };

    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // For autosave
    let lastSaveTime = 0;

    // ==================== UTILS: DIFFICULTY & TIMER ====================
    function getBaseTimeForLevel(level) {
        if (level <= 20) return CONFIG.BEGINNER_TIME;
        else if (level <= 30) return CONFIG.AVERAGE_TIME;
        else if (level <= 40) return CONFIG.EXPERT_TIME;
        else if (level <= 50) return CONFIG.PRO_TIME;
        else return CONFIG.INSANE_TIME;
    }

    // Time decreases gradually with level, floor at 10s
    function getTimeLimitForLevel(level) {
        const base = getBaseTimeForLevel(level);
        const dynamicReduction = level * 0.5; // 0.5s less per level
        return Math.max(10, base - dynamicReduction);
    }

    function getDifficultyName(level) {
        if (level <= 20) return "üü¢ Beginner";
        else if (level <= 30) return "üü° Average";
        else if (level <= 40) return "üü† Expert";
        else if (level <= 50) return "üî¥ Pro";
        else return "üíÄ INSANE";
    }

    // ==================== MAZE GENERATION ====================
    function generateMazeChunk() {
        const size = CONFIG.CHUNK_SIZE;
        const maze = Array(size).fill(null).map(() => Array(size).fill(1));

        function carve(x, y) {
            maze[y][x] = 0;
            const dirs = [
                [0, -2], [0, 2], [2, 0], [-2, 0]
            ].sort(() => Math.random() - 0.5);
            for (const [dx, dy] of dirs) {
                const nx = x + dx;
                const ny = y + dy;
                if (nx > 0 && nx < size - 1 && ny > 0 && ny < size - 1 && maze[ny][nx] === 1) {
                    maze[y + dy / 2][x + dx / 2] = 0;
                    carve(nx, ny);
                }
            }
        }

        carve(1, 1);
        maze[1][1] = 0;

        addRooms(maze);
        addDeadEnds(maze);
        addLoops(maze);
        ensureFullyConnected(maze);
        return maze;
    }

    function ensureFullyConnected(maze) {
        const size = CONFIG.CHUNK_SIZE;
        const visited = Array(size).fill(null).map(() => Array(size).fill(false));

        function floodFill(x, y) {
            if (x < 0 || x >= size || y < 0 || y >= size) return;
            if (visited[y][x] || maze[y][x] !== 0) return;
            visited[y][x] = true;
            floodFill(x + 1, y);
            floodFill(x - 1, y);
            floodFill(x, y + 1);
            floodFill(x, y - 1);
        }

        floodFill(1, 1);

        for (let y = 1; y < size - 1; y++) {
            for (let x = 1; x < size - 1; x++) {
                if (maze[y][x] === 0 && !visited[y][x]) {
                    connectToMainMaze(maze, visited, x, y);
                }
            }
        }
    }

    function connectToMainMaze(maze, visited, startX, startY) {
        const size = CONFIG.CHUNK_SIZE;
        const dirs = [{dx:1, dy:0}, {dx:-1, dy:0}, {dx:0, dy:1}, {dx:0, dy:-1}];
        let x = startX, y = startY, attempts = 0;

        while (!visited[y][x] && attempts < 200) {
            const dir = dirs[Math.floor(Math.random() * dirs.length)];
            const nx = x + dir.dx;
            const ny = y + dir.dy;
            if (nx > 0 && nx < size-1 && ny > 0 && ny < size-1) {
                maze[ny][nx] = 0;
                x = nx; y = ny;
            }
            attempts++;
        }
    }

    // Random goal placement each level, far-ish from start, reachable
    function findGoalPosition(maze) {
        const size = CONFIG.CHUNK_SIZE;
        const candidates = [];
        for (let y=1; y<size-1; y++) {
            for (let x=1; x<size-1; x++) {
                if (maze[y][x] === 0) {
                    const dist = Math.sqrt((x-1)**2 + (y-1)**2);
                    if (dist > size * 0.5) {
                        candidates.push({x,y,dist});
                    }
                }
            }
        }
        if (candidates.length === 0) {
            for (let y=1; y<size-1; y++) {
                for (let x=1; x<size-1; x++) {
                    if (maze[y][x] === 0) candidates.push({x,y,dist:0});
                }
            }
        }
        if (candidates.length === 0) return {x:size-2, y:size-2};
        return candidates[Math.floor(Math.random()*candidates.length)];
    }

    function addRooms(maze) {
        const size = CONFIG.CHUNK_SIZE;
        const numRooms = 2 + Math.floor(Math.random()*3);
        for (let i=0; i<numRooms; i++) {
            const w = 3 + Math.floor(Math.random()*3);
            const h = 3 + Math.floor(Math.random()*3);
            const startX = 2 + Math.floor(Math.random()*(size-w-4));
            const startY = 2 + Math.floor(Math.random()*(size-h-4));
            for (let y=startY; y<startY+h; y++) {
                for (let x=startX; x<startX+w; x++) {
                    if (x>0 && x<size-1 && y>0 && y<size-1) maze[y][x]=0;
                }
            }
            if (w>=5 && h>=5) {
                const px = startX + Math.floor(w/2);
                const py = startY + Math.floor(h/2);
                if (maze[py][px]===0) maze[py][px]=2; // pillar
            }
        }
    }

    function addDeadEnds(maze) {
        const size = CONFIG.CHUNK_SIZE;
        for (let y=2; y<size-2; y++) {
            for (let x=2; x<size-2; x++) {
                if (maze[y][x]===0) {
                    const neighbors = [
                        maze[y-1][x],maze[y+1][x],maze[y][x-1],maze[y][x+1]
                    ].filter(v=>v===0).length;
                    if (neighbors===1 && Math.random()<0.3) {
                        const dirs = [{dx:0,dy:-1},{dx:0,dy:1},{dx:-1,dy:0},{dx:1,dy:0}];
                        for (const d of dirs) {
                            const nx=x+d.dx, ny=y+d.dy;
                            if (nx>0 && nx<size-1 && ny>0 && ny<size-1 && maze[ny][nx]===1) {
                                maze[ny][nx]=0; break;
                            }
                        }
                    }
                }
            }
        }
    }

    function addLoops(maze) {
        const size = CONFIG.CHUNK_SIZE;
        const numLoops = 3 + Math.floor(Math.random()*5);
        for (let i=0; i<numLoops; i++) {
            const x = 2 + Math.floor(Math.random()*(size-4));
            const y = 2 + Math.floor(Math.random()*(size-4));
            if (maze[y][x]===1) {
                const neighbors = [
                    maze[y-1][x],maze[y+1][x],maze[y][x-1],maze[y][x+1]
                ].filter(v=>v===0).length;
                if (neighbors>=2) maze[y][x]=0;
            }
        }
    }

    // ==================== COLLECTIBLES ====================
    function spawnPowerups() {
        gameState.powerups = [];
        const num = 2 + Math.floor(gameState.currentChunk/3);
        for (let i=0; i<num; i++) {
            let x,y,attempts=0;
            do {
                x = 1 + Math.floor(Math.random()*(CONFIG.CHUNK_SIZE-2));
                y = 1 + Math.floor(Math.random()*(CONFIG.CHUNK_SIZE-2));
                attempts++;
            } while (
                attempts<100 &&
                (gameState.maze[y][x]!==0 ||
                 (x===gameState.player.x && y===gameState.player.y) ||
                 (x===gameState.goal.x && y===gameState.goal.y))
            );
            if (attempts<100) {
                const types=Object.keys(POWERUP_TYPES);
                const type=types[Math.floor(Math.random()*types.length)];
                gameState.powerups.push({x,y,type,collected:false});
            }
        }
    }

    function spawnCoins() {
        gameState.coins=[];
        const base = gameState.isSpecialLevel ? 15 : 5;
        const num = base + Math.floor(gameState.currentChunk/5);
        for (let i=0; i<num; i++) {
            let x,y,attempts=0;
            do {
                x = 1 + Math.floor(Math.random()*(CONFIG.CHUNK_SIZE-2));
                y = 1 + Math.floor(Math.random()*(CONFIG.CHUNK_SIZE-2));
                attempts++;
            } while (
                attempts<100 &&
                (gameState.maze[y][x]!==0 ||
                 (x===gameState.player.x && y===gameState.player.y) ||
                 (x===gameState.goal.x && y===gameState.goal.y))
            );
            if (attempts<100) {
                const value = gameState.isSpecialLevel ? 20 : 10;
                gameState.coins.push({x,y,value,collected:false});
            }
        }
    }

    function spawnChests() {
        gameState.chests=[];
        if (Math.random()<CONFIG.CHEST_SPAWN_CHANCE || gameState.isSpecialLevel) {
            const num = gameState.isSpecialLevel ? 2 : 1;
            for (let i=0;i<num;i++) {
                let x,y,attempts=0;
                do {
                    x = 1 + Math.floor(Math.random()*(CONFIG.CHUNK_SIZE-2));
                    y = 1 + Math.floor(Math.random()*(CONFIG.CHUNK_SIZE-2));
                    attempts++;
                } while (
                    attempts<100 &&
                    (gameState.maze[y][x]!==0 ||
                     (x===gameState.player.x && y===gameState.player.y) ||
                     (x===gameState.goal.x && y===gameState.goal.y))
                );
                if (attempts<100) {
                    const reward = gameState.isSpecialLevel ? 100 : 50;
                    gameState.chests.push({x,y,reward,opened:false});
                }
            }
        }
    }

    function initializeChunk() {
        gameState.maze = generateMazeChunk();
        gameState.player = {x:1, y:1};
        gameState.previousPosition = {x:1, y:1};
        gameState.goal = findGoalPosition(gameState.maze); // üîÅ randomized each level

        gameState.visited = Array(CONFIG.CHUNK_SIZE).fill(null)
            .map(()=>Array(CONFIG.CHUNK_SIZE).fill(false));
        gameState.visited[gameState.player.y][gameState.player.x]=true;

        gameState.isSpecialLevel = Math.random()<CONFIG.SPECIAL_LEVEL_CHANCE;
        document.getElementById('specialIndicator').style.display =
            gameState.isSpecialLevel ? 'block' : 'none';

        if (gameState.isSpecialLevel) showSpecialLevelMessage();

        gameState.timeRemaining = getTimeLimitForLevel(gameState.currentChunk);
        gameState.maxTimeForLevel = gameState.timeRemaining;
        gameState.levelStartTime = Date.now();

        spawnPowerups();
        spawnCoins();
        spawnChests();
    }

    // ==================== POPUPS ====================
    function showSpecialLevelMessage() {
        const msg=document.getElementById('specialLevelMessage');
        msg.classList.add('show');
        setTimeout(()=>msg.classList.remove('show'),1500);
    }

    function collectCoin(coin) {
        if (coin.collected) return;
        coin.collected=true;
        gameState.totalCoins += coin.value;
        updateCoinDisplay();
        playCoinSound();
    }

    function openChest(chest) {
        if (chest.opened) return;
        chest.opened=true;
        gameState.totalCoins += chest.reward;
        updateCoinDisplay();

        const msg=document.getElementById('chestMessage');
        document.getElementById('chestReward').textContent = `+${chest.reward} coins!`;
        msg.classList.add('show');
        setTimeout(()=>msg.classList.remove('show'),1500);
        playChestSound();
    }

    function checkCollectibles() {
        for (const c of gameState.coins) {
            if (!c.collected && c.x===gameState.player.x && c.y===gameState.player.y) {
                collectCoin(c);
            }
        }
        for (const chest of gameState.chests) {
            if (!chest.opened && chest.x===gameState.player.x && chest.y===gameState.player.y) {
                openChest(chest);
            }
        }
    }

    // ==================== SHOP ====================
    function openShop() {
        renderShop();
        document.getElementById('shopModal').classList.add('show');
    }

    function closeShop() {
        document.getElementById('shopModal').classList.remove('show');
    }

    function renderShop() {
        const grid=document.getElementById('shopGrid');
        const bankEl=document.getElementById('shopBankCoinCount');
        grid.innerHTML='';
        bankEl.textContent = scoreboard.bankCoins;

        const colorHeader=document.createElement('div');
        colorHeader.style.gridColumn='1 / -1';
        colorHeader.innerHTML='<h3 style="color:#a5b4fc;margin:4px 0;">üé® Player Colors</h3>';
        grid.appendChild(colorHeader);

        COSMETICS.colors.forEach(item=>{
            const div=document.createElement('div');
            div.className='shop-item';
            if (item.owned) div.classList.add('owned');
            if (gameState.playerCosmetics.color===item.color) div.classList.add('equipped');
            div.innerHTML = `
                <div class="shop-item-icon" style="color:${item.color}">‚óè</div>
                <div>${item.name}</div>
                <div class="shop-item-price">
                    ${item.owned ? (gameState.playerCosmetics.color===item.color ? 'EQUIPPED' : 'OWNED') : item.price + ' üí∞'}
                </div>`;
            div.onclick=()=>purchaseOrEquip('color', item);
            grid.appendChild(div);
        });

        const trailHeader=document.createElement('div');
        trailHeader.style.gridColumn='1 / -1';
        trailHeader.innerHTML='<h3 style="color:#a5b4fc;margin:6px 0;">‚ú® Trail Effects</h3>';
        grid.appendChild(trailHeader);

        const icons={none:'üö´', sparkle:'‚ú®', fire:'üî•', rainbow:'üåà'};
        COSMETICS.trails.forEach(item=>{
            const div=document.createElement('div');
            div.className='shop-item';
            if (item.owned) div.classList.add('owned');
            if (gameState.playerCosmetics.trail===item.effect) div.classList.add('equipped');
            div.innerHTML = `
                <div class="shop-item-icon">${icons[item.effect]}</div>
                <div>${item.name}</div>
                <div class="shop-item-price">
                    ${item.owned ? (gameState.playerCosmetics.trail===item.effect ? 'EQUIPPED' : 'OWNED') : item.price + ' üí∞'}
                </div>`;
            div.onclick=()=>purchaseOrEquip('trail', item);
            grid.appendChild(div);
        });
    }

    function purchaseOrEquip(type, item) {
        if (type==='color') {
            if (!item.owned) {
                if (scoreboard.bankCoins < item.price) {
                    alert('Not enough bank coins!');
                    return;
                }
                scoreboard.bankCoins -= item.price;
                item.owned=true;
                saveScores();
                playPurchaseSound();
            }
            gameState.playerCosmetics.color=item.color;
        } else {
            if (!item.owned) {
                if (scoreboard.bankCoins < item.price) {
                    alert('Not enough bank coins!');
                    return;
                }
                scoreboard.bankCoins -= item.price;
                item.owned=true;
                saveScores();
                playPurchaseSound();
            }
            gameState.playerCosmetics.trail=item.effect;
        }
        renderShop();
    }

    // ==================== TRAILS ====================
    function createTrailParticle() {
        if (gameState.playerCosmetics.trail==='none') return;
        gameState.trailParticles.push({
            x:gameState.player.x,
            y:gameState.player.y,
            life:30,
            type:gameState.playerCosmetics.trail
        });
    }

    function updateTrailParticles() {
        gameState.trailParticles = gameState.trailParticles.filter(p=>--p.life>0);
    }

    function drawTrailParticles(offsetX, offsetY, tileSize) {
        for (const p of gameState.trailParticles) {
            const alpha = p.life/30;
            const sx = offsetX + p.x*tileSize + tileSize/2;
            const sy = offsetY + p.y*tileSize + tileSize/2;
            ctx.globalAlpha = alpha*0.7;
            switch(p.type){
                case 'sparkle':
                    ctx.fillStyle='#ffd700';
                    ctx.beginPath(); ctx.arc(sx,sy,3,0,Math.PI*2); ctx.fill();
                    break;
                case 'fire':
                    ctx.fillStyle='#ff6600';
                    ctx.beginPath(); ctx.arc(sx,sy,4,0,Math.PI*2); ctx.fill();
                    break;
                case 'rainbow':
                    const hue=(Date.now()/10)%360;
                    ctx.fillStyle=`hsl(${hue},100%,50%)`;
                    ctx.beginPath(); ctx.arc(sx,sy,5,0,Math.PI*2); ctx.fill();
                    break;
            }
            ctx.globalAlpha=1;
        }
    }

    // ==================== POWER-UPS ====================
    function collectPowerup(powerup) {
        if (powerup.collected) return;
        powerup.collected=true;
        const type=powerup.type;
        switch(type){
            case 'VISION':
                gameState.activePowerups.vision = {
                    active:true,
                    endTime:Date.now()+POWERUP_TYPES.VISION.duration
                };
                gameState.visibilityRadius = CONFIG.BASE_VISIBILITY_RADIUS+3;
                break;
            case 'TIME':
                gameState.timeRemaining += 15;
                document.getElementById('timeBonus').textContent='+15s';
                setTimeout(()=>document.getElementById('timeBonus').textContent='+0s',2000);
                break;
            case 'REVEAL':
                gameState.activePowerups.reveal = {
                    active:true,
                    endTime:Date.now()+POWERUP_TYPES.REVEAL.duration
                };
                break;
        }
        updatePowerupDisplay();
        playPowerupSound();
    }

    function checkPowerupCollection() {
        for (const p of gameState.powerups) {
            if (!p.collected &&
                p.x===gameState.player.x &&
                p.y===gameState.player.y) {
                collectPowerup(p);
            }
        }
    }

    function updatePowerupDisplay() {
        const now=Date.now();
        const visionEl=document.getElementById('visionLevel');
        const revealEl=document.getElementById('revealPower');

        if (gameState.activePowerups.vision.active) {
            if (now<gameState.activePowerups.vision.endTime) {
                const rem = Math.ceil((gameState.activePowerups.vision.endTime-now)/1000);
                visionEl.textContent = `Enhanced (${rem}s)`;
                visionEl.style.color='#facc15';
            } else {
                gameState.activePowerups.vision.active=false;
                gameState.visibilityRadius=CONFIG.BASE_VISIBILITY_RADIUS;
                visionEl.textContent='Normal';
                visionEl.style.color='';
            }
        } else {
            visionEl.textContent='Normal';
            visionEl.style.color='';
        }

        if (gameState.activePowerups.reveal.active) {
            if (now<gameState.activePowerups.reveal.endTime) {
                const rem = Math.ceil((gameState.activePowerups.reveal.endTime-now)/1000);
                revealEl.textContent=`Active (${rem}s)`;
                revealEl.style.color='#facc15';
            } else {
                gameState.activePowerups.reveal.active=false;
                revealEl.textContent='Inactive';
                revealEl.style.color='';
            }
        } else {
            revealEl.textContent='Inactive';
            revealEl.style.color='';
        }
    }

    // ==================== VISIBILITY ====================
    function hasLineOfSight(x0,y0,x1,y1) {
        let dx=Math.abs(x1-x0);
        let dy=Math.abs(y1-y0);
        const sx=x0<x1?1:-1;
        const sy=y0<y1?1:-1;
        let err=dx-dy;
        let x=x0, y=y0;
        while(true){
            if (x>=0 && x<CONFIG.CHUNK_SIZE && y>=0 && y<CONFIG.CHUNK_SIZE) {
                const cell=gameState.maze[y][x];
                if (cell===1 || cell===2) return false;
            }
            if (x===x1 && y===y1) break;
            const e2=2*err;
            if (e2>-dy) { err-=dy; x+=sx; }
            if (e2<dx) { err+=dx; y+=sy; }
        }
        return true;
    }

    function isVisible(x,y) {
        if (gameState.activePowerups.reveal.active) return true;
        const px=gameState.player.x, py=gameState.player.y;
        const dist=Math.sqrt((x-px)**2 + (y-py)**2);
        if (dist>gameState.visibilityRadius) return false;
        return hasLineOfSight(px,py,x,y);
    }

    function isVisibleFromMarker(x,y) {
        if (gameState.activePowerups.reveal.active) return true;
        for (const m of gameState.markers) {
            if (m.chunkId!==gameState.currentChunk) continue;
            const dist=Math.sqrt((x-m.x)**2 + (y-m.y)**2);
            if (dist<=CONFIG.BASE_MARKER_VISIBILITY_RADIUS &&
                hasLineOfSight(m.x,m.y,x,y)) return true;
        }
        return false;
    }

    function isAdjacentToVisible(x,y) {
        for (let dy=-1; dy<=1; dy++) {
            for (let dx=-1; dx<=1; dx++) {
                const nx=x+dx, ny=y+dy;
                if (nx>=0 && nx<CONFIG.CHUNK_SIZE &&
                    ny>=0 && ny<CONFIG.CHUNK_SIZE) {
                    if (isVisible(nx,ny) || isVisibleFromMarker(nx,ny)) return true;
                }
            }
        }
        return false;
    }

    // ==================== MARKERS ====================
    function placeMarker() {
        const px=gameState.player.x, py=gameState.player.y;
        const exists = gameState.markers.some(m=>m.x===px && m.y===py && m.chunkId===gameState.currentChunk);
        if (!exists) {
            gameState.markers.push({x:px, y:py, chunkId:gameState.currentChunk});
            updateMarkerCount();
            playMarkerSound();
        }
    }

    function updateMarkerCount() {
        const count=gameState.markers.filter(m=>m.chunkId===gameState.currentChunk).length;
        document.getElementById('markerCount').textContent=count;
    }

    // ==================== MOVEMENT / INPUT ====================
    function attemptMove(direction) {
        if (gameState.gameOver) return;
        let nx=gameState.player.x, ny=gameState.player.y;
        if (direction==='up') ny--;
        else if (direction==='down') ny++;
        else if (direction==='left') nx--;
        else if (direction==='right') nx++;
        else return;

        if (nx>=0 && nx<CONFIG.CHUNK_SIZE &&
            ny>=0 && ny<CONFIG.CHUNK_SIZE &&
            gameState.maze[ny][nx]===0) {
            gameState.previousPosition={...gameState.player};
            gameState.player.x=nx;
            gameState.player.y=ny;
            gameState.steps++;
            gameState.isMoving=true;
            gameState.animationProgress=0;
            createTrailParticle();
            gameState.visited[ny][nx]=true;
            checkPowerupCollection();
            checkCollectibles();
            updateStats();
            checkForGoal();
        }
    }

    function handleKeydown(e) {
        if (gameState.gameOver) return;
        if (e.key==='Shift') {
            placeMarker();
            return;
        }
        const key=e.key.toLowerCase();
        if (key==='w') attemptMove('up');
        else if (key==='s') attemptMove('down');
        else if (key==='a') attemptMove('left');
        else if (key==='d') attemptMove('right');
    }

    function initMobileControls() {
        const container=document.getElementById('mobileControls');
        container.addEventListener('click',e=>{
            const btn=e.target.closest('.mobile-btn');
            if (!btn) return;
            const dir=btn.getAttribute('data-dir');
            if (!dir) return;
            attemptMove(dir);
        });
        document.getElementById('mobileMarkerBtn')
            .addEventListener('click',placeMarker);
    }

    // ==================== TIMER / GAME OVER ====================
    function updateTimer(delta) {
        if (gameState.gameOver) return;
        gameState.timeRemaining -= delta/1000;
        if (gameState.timeRemaining<=0) {
            gameState.timeRemaining=0;
            gameOver();
        }
        const sec=Math.ceil(gameState.timeRemaining);
        document.getElementById('timerText').textContent=`${sec}s`;
        const pct=(gameState.timeRemaining/gameState.maxTimeForLevel)*100;
        const fill=document.getElementById('timerFill');
        fill.style.width=`${Math.max(0,Math.min(100,pct))}%`;
        fill.className='timer-fill';
        if (pct<20) fill.classList.add('critical');
        else if (pct<40) fill.classList.add('warning');
    }

    function depositRunCoinsIntoBank() {
        if (gameState.totalCoins>0) {
            scoreboard.bankCoins += gameState.totalCoins;
            scoreboard.bestCoinsRun = Math.max(scoreboard.bestCoinsRun, gameState.totalCoins);
            gameState.totalCoins=0;
            saveScores();
        }
    }

    function updateScoresOnGameOver() {
        const levelsCompleted = gameState.currentChunk-1;
        scoreboard.bestLevel = Math.max(scoreboard.bestLevel, levelsCompleted);

        if (gameState.fastestLevelTimeThisRun!=null) {
            if (scoreboard.fastestLevelTime==null ||
                gameState.fastestLevelTimeThisRun < scoreboard.fastestLevelTime) {
                scoreboard.fastestLevelTime = gameState.fastestLevelTimeThisRun;
            }
        }
        scoreboard.runsPlayed += 1;
        depositRunCoinsIntoBank();
    }

    function gameOver() {
        if (gameState.gameOver) return;
        gameState.gameOver=true;
        updateScoresOnGameOver();
        document.getElementById('finalChunks').textContent = gameState.currentChunk-1;
        document.getElementById('finalCoins').textContent = scoreboard.bestCoinsRun;
        document.getElementById('gameOverMessage').classList.add('show');
        saveScores();
        localStorage.removeItem(SAVE_KEY);
        playGameOverSound();
    }

    function handleRestart() {
        document.getElementById('gameOverMessage').classList.remove('show');
        startNewGame();
    }

    // ==================== GOAL / PROGRESSION ====================
    function checkForGoal() {
        if (gameState.player.x===gameState.goal.x &&
            gameState.player.y===gameState.goal.y) {
            const now=Date.now();
            if (gameState.levelStartTime!=null) {
                const elapsed=(now-gameState.levelStartTime)/1000;
                if (gameState.fastestLevelTimeThisRun==null ||
                    elapsed<gameState.fastestLevelTimeThisRun) {
                    gameState.fastestLevelTimeThisRun=elapsed;
                }
            }
            const msg=document.getElementById('victoryMessage');
            msg.classList.add('show');
            playVictorySound();
            setTimeout(()=>{
                msg.classList.remove('show');
                gameState.currentChunk++;
                initializeChunk();
                updateStats();
                updateMarkerCount();
            },1200);
        }
    }

    // ==================== RENDERING ====================
    function easeOutCubic(x){ return 1 - Math.pow(1-x,3); }

    function drawMaze() {
        if (!gameState.maze.length) return;
        ctx.clearRect(0,0,canvas.width,canvas.height);
        const size=CONFIG.CHUNK_SIZE;
        const tileSize=getTileSize();
        const offsetX=(canvas.width - size*tileSize)/2;
        const offsetY=(canvas.height - size*tileSize)/2;

        ctx.fillStyle='#020617';
        ctx.fillRect(0,0,canvas.width,canvas.height);

        for (let y=0; y<size; y++) {
            for (let x=0; x<size; x++) {
                const sx=offsetX + x*tileSize;
                const sy=offsetY + y*tileSize;
                const cell=gameState.maze[y][x];
                const vis=isVisible(x,y);
                const visFromMarker=isVisibleFromMarker(x,y);
                if (vis || visFromMarker) {
                    if (cell===1) {
                        ctx.fillStyle='#1f2937';
                        ctx.fillRect(sx,sy,tileSize,tileSize);
                        ctx.strokeStyle='#020617';
                        ctx.strokeRect(sx,sy,tileSize,tileSize);
                    } else if (cell===2) {
                        ctx.fillStyle='#111827';
                        ctx.fillRect(sx,sy,tileSize,tileSize);
                        ctx.fillStyle='#374151';
                        ctx.fillRect(sx+tileSize/4, sy+tileSize/4, tileSize/2, tileSize/2);
                        ctx.strokeStyle='#1f2937';
                        ctx.strokeRect(sx+tileSize/4, sy+tileSize/4, tileSize/2, tileSize/2);
                    } else {
                        const v=(x*7 + y*13)%5;
                        if (v===0) ctx.fillStyle='#0f172a';
                        else if (v===1) ctx.fillStyle='#020617';
                        else ctx.fillStyle='#111827';
                        ctx.fillRect(sx,sy,tileSize,tileSize);
                        if (v===0) {
                            ctx.strokeStyle='#020617';
                            ctx.beginPath();
                            ctx.moveTo(sx+2, sy+tileSize-4);
                            ctx.lineTo(sx+tileSize-3, sy+3);
                            ctx.stroke();
                        }
                    }
                    if (x===gameState.goal.x && y===gameState.goal.y) {
                        const pulse=Math.sin(Date.now()/300)*0.12+0.9;
                        ctx.fillStyle='#22c55e';
                        ctx.beginPath();
                        ctx.arc(sx+tileSize/2, sy+tileSize/2, (tileSize/3)*pulse, 0, Math.PI*2);
                        ctx.fill();
                        ctx.strokeStyle='#166534';
                        ctx.beginPath();
                        ctx.arc(sx+tileSize/2, sy+tileSize/2, (tileSize/4)*pulse, 0, Math.PI*2);
                        ctx.stroke();
                    }
                } else if (cell===1 && isAdjacentToVisible(x,y)) {
                    ctx.fillStyle='#020617';
                    ctx.fillRect(sx,sy,tileSize,tileSize);
                } else {
                    ctx.fillStyle='#000000';
                    ctx.fillRect(sx,sy,tileSize,tileSize);
                }
            }
        }

        // coins
        for (const c of gameState.coins) {
            if (!c.collected && (isVisible(c.x,c.y) || isVisibleFromMarker(c.x,c.y))) {
                const sx=offsetX + c.x*tileSize + tileSize/2;
                const sy=offsetY + c.y*tileSize + tileSize/2;
                ctx.fillStyle='#facc15';
                ctx.beginPath(); ctx.arc(sx,sy,tileSize/4,0,Math.PI*2); ctx.fill();
                ctx.strokeStyle='#f97316';
                ctx.stroke();
            }
        }

        // chests
        for (const chest of gameState.chests) {
            if (!chest.opened && (isVisible(chest.x,chest.y) || isVisibleFromMarker(chest.x,chest.y))) {
                const sx=offsetX + chest.x*tileSize;
                const sy=offsetY + chest.y*tileSize;
                ctx.fillStyle='#8b4513';
                ctx.fillRect(sx+tileSize/4, sy+tileSize/4, tileSize/2, tileSize/2);
                ctx.strokeStyle='#4b2a0b';
                ctx.strokeRect(sx+tileSize/4, sy+tileSize/4, tileSize/2, tileSize/2);
                ctx.fillStyle='#facc15';
                ctx.fillRect(sx+tileSize/2-2, sy+tileSize/2-2,4,4);
            }
        }

        // powerups
        for (const p of gameState.powerups) {
            if (!p.collected && (isVisible(p.x,p.y) || isVisibleFromMarker(p.x,p.y))) {
                const sx=offsetX + p.x*tileSize + tileSize/2;
                const sy=offsetY + p.y*tileSize + tileSize/2;
                const grad=ctx.createRadialGradient(sx,sy,0,sx,sy,tileSize/2);
                grad.addColorStop(0, POWERUP_TYPES[p.type].color);
                grad.addColorStop(1, 'transparent');
                ctx.fillStyle=grad;
                ctx.fillRect(sx-tileSize/2, sy-tileSize/2, tileSize, tileSize);
                ctx.fillStyle=POWERUP_TYPES[p.type].color;
                ctx.beginPath(); ctx.arc(sx,sy,tileSize/3,0,Math.PI*2); ctx.fill();
                ctx.font=`${tileSize/2}px Arial`;
                ctx.textAlign='center'; ctx.textBaseline='middle';
                ctx.fillText(POWERUP_TYPES[p.type].emoji, sx, sy+1);
            }
        }

        // markers
        for (const m of gameState.markers) {
            if (m.chunkId!==gameState.currentChunk) continue;
            const vis=isVisible(m.x,m.y) || isVisibleFromMarker(m.x,m.y);
            if (!vis) continue;
            const sx=offsetX + m.x*tileSize + tileSize/2;
            const sy=offsetY + m.y*tileSize + tileSize/2;
            ctx.fillStyle='#facc15';
            ctx.beginPath(); ctx.arc(sx,sy,tileSize/4,0,Math.PI*2); ctx.fill();
            ctx.fillStyle='#fb7185';
            ctx.beginPath(); ctx.arc(sx,sy,tileSize/6,0,Math.PI*2); ctx.fill();
        }

        drawTrailParticles(offsetX, offsetY, tileSize);
        drawPlayer(offsetX, offsetY, tileSize);
    }

    function drawPlayer(offsetX, offsetY, tileSize) {
        let dx=gameState.player.x;
        let dy=gameState.player.y;
        if (gameState.isMoving && gameState.animationProgress<1) {
            const t=easeOutCubic(gameState.animationProgress);
            dx = gameState.previousPosition.x +
                 (gameState.player.x-gameState.previousPosition.x)*t;
            dy = gameState.previousPosition.y +
                 (gameState.player.y-gameState.previousPosition.y)*t;
        }
        const sx=offsetX + dx*tileSize + tileSize/2;
        const sy=offsetY + dy*tileSize + tileSize/2;
        ctx.fillStyle=gameState.playerCosmetics.color;
        ctx.beginPath(); ctx.arc(sx,sy,tileSize/3,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#e5e7eb'; ctx.lineWidth=2;
        ctx.stroke();
    }

    // ==================== UI UPDATES ====================
    function updateStats() {
        document.getElementById('stepCounter').textContent=gameState.steps;
        document.getElementById('chunkCounter').textContent=gameState.currentChunk;
        const diff=getDifficultyName(gameState.currentChunk);
        document.getElementById('difficultyDisplay').textContent=diff;
        document.getElementById('chunkIndicator').textContent=`Level ${gameState.currentChunk} - ${diff}`;
    }

    function updateCoinDisplay() {
        const runEl=document.getElementById('runCoinCount');
        const bankEl=document.getElementById('bankCoinCount');
        const shopEl=document.getElementById('shopBankCoinCount');
        if (runEl) runEl.textContent=gameState.totalCoins;
        if (bankEl) bankEl.textContent=scoreboard.bankCoins;
        if (shopEl) shopEl.textContent=scoreboard.bankCoins;
    }

    // ==================== SAVE / LOAD RUN ====================
    function getSerializableGameState() {
        return {
            maze: gameState.maze,
            player: gameState.player,
            goal: gameState.goal,
            visited: gameState.visited,
            markers: gameState.markers,
            powerups: gameState.powerups,
            coins: gameState.coins,
            chests: gameState.chests,
            playerCosmetics: gameState.playerCosmetics,
            totalCoins: gameState.totalCoins,
            steps: gameState.steps,
            currentChunk: gameState.currentChunk,
            chunkOffsetX: gameState.chunkOffsetX,
            chunkOffsetY: gameState.chunkOffsetY,
            timeRemaining: gameState.timeRemaining,
            maxTimeForLevel: gameState.maxTimeForLevel,
            visibilityRadius: gameState.visibilityRadius,
            isSpecialLevel: gameState.isSpecialLevel,
            levelStartTime: gameState.levelStartTime,
            fastestLevelTimeThisRun: gameState.fastestLevelTimeThisRun,
            activePowerups: gameState.activePowerups
        };
    }

    function saveRun() {
        if (gameState.gameOver) {
            localStorage.removeItem(SAVE_KEY);
            return;
        }
        try {
            localStorage.setItem(SAVE_KEY, JSON.stringify(getSerializableGameState()));
        } catch (e) {
            console.warn('Could not save run:', e);
        }
    }

    function loadRunState() {
        const raw=localStorage.getItem(SAVE_KEY);
        if (!raw) return false;
        try {
            const saved=JSON.parse(raw);
            Object.assign(gameState, saved);
            updateStats();
            updateMarkerCount();
            updateCoinDisplay();
            document.getElementById('specialIndicator').style.display =
                gameState.isSpecialLevel ? 'block' : 'none';
            return true;
        } catch (e) {
            console.warn('Could not load run:', e);
            return false;
        }
    }

    function updateMenuButtons() {
        const btn=document.getElementById('continueBtn');
        const hasSave=!!localStorage.getItem(SAVE_KEY);
        btn.disabled = !hasSave;
        btn.textContent = hasSave ? '‚ñ∂ Continue' : 'No Save Available';
    }

    function openMenu() {
        updateMenuButtons();
        document.getElementById('menuModal').classList.add('show');
    }

    function closeMenu() {
        document.getElementById('menuModal').classList.remove('show');
    }

    function startNewGame() {
        // bank any remaining run coins
        depositRunCoinsIntoBank();
        saveScores();

        localStorage.removeItem(SAVE_KEY);

        gameState.steps=0;
        gameState.currentChunk=1;
        gameState.markers=[];
        gameState.trailParticles=[];
        gameState.activePowerups = {
            vision:{active:false,endTime:0},
            reveal:{active:false,endTime:0}
        };
        gameState.visibilityRadius=CONFIG.BASE_VISIBILITY_RADIUS;
        gameState.fastestLevelTimeThisRun=null;
        gameState.gameOver=false;

        initializeChunk();
        updateStats();
        updateMarkerCount();
        updateCoinDisplay();

        closeMenu();
    }

    function continueGame() {
        if (!loadRunState()) {
            startNewGame();
            return;
        }
        gameState.gameOver=false;
        closeMenu();
    }

    // ==================== AUDIO STUBS (no sound in this version) ====================
    function playVictorySound() {}
    function playMarkerSound() {}
    function playPowerupSound() {}
    function playCoinSound() {}
    function playChestSound() {}
    function playPurchaseSound() {}
    function playGameOverSound() {}

    // ==================== GAME LOOP / RESIZE ====================
    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function gameLoop() {
        const now=Date.now();
        const dt=now - gameState.lastFrameTime;
        gameState.lastFrameTime=now;

        if (gameState.isMoving) {
            gameState.animationProgress += 0.35;
            if (gameState.animationProgress>=1) {
                gameState.animationProgress=1;
                gameState.isMoving=false;
            }
        }

        updateTimer(dt);
        updatePowerupDisplay();
        updateTrailParticles();
        drawMaze();

        if (!gameState.gameOver && now-lastSaveTime>2000) {
            saveRun();
            lastSaveTime=now;
        }

        requestAnimationFrame(gameLoop);
    }

    function init() {
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        initMobileControls();
        document.addEventListener('keydown', handleKeydown);
        loadScores();
        updateMenuButtons();

        // We don't auto-start a run; menu is open with New/Continue
        gameState.lastFrameTime=Date.now();
        gameLoop();
    }

    init();
</script>
</body>
</html>
